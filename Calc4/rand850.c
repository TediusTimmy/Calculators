/*
   rand850: a linear congruential pseudo-random number generator with
      approximately 850 bits of state.

   Copyright (C) 2013 Thomas DiModica <ricinwich@yahoo.com>
      2010 version used own math routines. 2013 version uses GMP.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
   File: rand850.c
      This is a random number generator that generates pseudo-random numbers
      on a period 10 ^ 256 using a linear congruential generator.

      It has four invocations: rand850s, which returns the digits as a string,
      rand850ul, which returns an unsigned long, rand850i, which takes a long
      input and returns an "int" on [0, input), and rand850sl, which takes
      two signed long inputs and returns a signed long ouput on [input,input].

      To get a standard long from rand850ul, bitshift it right one (>> 1).
      rand850ul SHOULD have a period of about 2 ^ 820 (~ 10 ^ 246).

      Has two seeding functions: srand850 takes a standard long as would be
      generated by time(). srand850s takes a character pointer and treats the
      data it points at as a base-93 number (Use it with ASCII strings).

      This was originally written to be part of a C++ project, so it is
      already wrappered to be compiled by either a C or C++ compiler.
*/
#include <gmp.h>

#ifdef __cplusplus
extern "C"
 {
#endif

static mpz_t state, constant_a, constant_c, mod;
// Constant A : 4 * 5 * 32771 ^ 53 * 65537 ^ 3 + 1
// Constant C : 65537 ^ 53
static int once = 1;

static char retbuf [260];

static void initialize()
 {
   if (once)
    {
      once = 0;
      mpz_init(state);
      mpz_init(constant_a);
      mpz_init(constant_c);
      mpz_init(mod);

      mpz_ui_pow_ui(constant_a, 32771UL, 53UL);
      mpz_ui_pow_ui(constant_c, 65537UL, 3UL);
      mpz_mul(constant_a, constant_a, constant_c);
      mpz_mul_ui(constant_a, constant_a, 20UL);
      mpz_add_ui(constant_a, constant_a, 1UL);

      mpz_ui_pow_ui(constant_c, 65537UL, 53UL);

      mpz_ui_pow_ui(mod, 10UL, 256UL);
    }
 }

/*
==============================================================================
   Function: seed random number generator
------------------------------------------------------------------------------
   NOTES:
      There aren't enough degrees of freedom from this random seed, however
      I don't believe that there is a good way to generate a seed that has
      sufficient freedom.
      Basically, upon seeding, you will only see one of four billion initial
      sequences. The only way this would be a problem is if you want EVERY
      possible shuffle of a deck of cards to be equiprobable upon seeding.
      As it is now, only about 10^9 of 10^67 shuffles will show up UPON
      SEEDING. I don't know enough math to make predictions upon shuffles
      after the first.
==============================================================================
*/
void srand850 (unsigned long a)
 {
   initialize();
   mpz_set_ui(state, a);
 }


/*
==============================================================================
   Function: random number string
------------------------------------------------------------------------------
   NOTES:
      From Knuth, TAOCP Vol. 2:
         x = (a * x + c) mod m
         c MUST be relatively prime to m
         a - 1 MUST be divisable by the prime factors of m
         a - 1 MUST be divisable by 4, if m is divisable by 4
      So:
         a = 4 * 5 * 32771 ^ 53 * 65537 ^ 3 + 1
         c = 65537 ^ 53
         m = 10 ^ 256 (which means we have about 850 bits of state)

         c and m are relatively prime, as 65537 is prime.
==============================================================================
*/
char * rand850s (void)
 {
   mpz_mul(state, state, constant_a);
   mpz_add(state, state, constant_c);
   mpz_tdiv_r(state, state, mod);

   gmp_snprintf(retbuf, 260, "%Zd", state);

   return retbuf;
 }


/*
==============================================================================
   Function: random number unsigned long
------------------------------------------------------------------------------
   NOTES:
      So, we interpret the state as a fractional number and multiply it by
      2 ^ 32 (4,294,967,296).
      The integral portion of the product is then stored in the digits past
      256, and will be in [0, 4294967295], the range of an unsigned long.

      This function is useful for creating output that the Diehard Battery
      will accept.
==============================================================================
*/
unsigned long rand850ul (void)
 {
   mpz_t temp;
   unsigned long result;

   mpz_mul(state, state, constant_a);
   mpz_add(state, state, constant_c);
   mpz_tdiv_r(state, state, mod);

   mpz_init(temp);
   mpz_ui_pow_ui(temp, 2UL, 32UL);

   mpz_mul(temp, state, temp);
   mpz_tdiv_q(temp, temp, mod);

   result = mpz_get_ui(temp);
   mpz_clear(temp);

   return result;
 }

/*
==============================================================================
   Function: random number int
------------------------------------------------------------------------------
   NOTES:
      Returns an "int" in [0,num_max). Use this to ensure that you are using
      the most significant, and therefore most random, bits of the state in
      generating your random numbers.
==============================================================================
*/
int rand850i (unsigned long num_max)
 {
   mpz_t temp;
   unsigned long result;

   mpz_mul(state, state, constant_a);
   mpz_add(state, state, constant_c);
   mpz_tdiv_r(state, state, mod);

   mpz_init_set_si(temp, num_max);

   mpz_mul(temp, state, temp);
   mpz_tdiv_q(temp, temp, mod);

   result = mpz_get_ui(temp);
   mpz_clear(temp);

   return (int)result;
 }

/*
==============================================================================
   Function: seed random number generator with string
------------------------------------------------------------------------------
   NOTES:
      A way to create enough freedom to allow any shuffle to be possible, if
      you have a way of getting a truely random string.

      Also, as a thought: encryption with a password string:
         Input password, use as seed.
         XOR data to encrypt with output of rand850ul.

      Takes in a printable ASCII string (codepoints 32 to 126) and throws out
      ' ' (32) and '~' (126) to have an input set of 93 characters. Why 93?
      If it were 94, the least-significant digit would always be even, if 95,
      that digit is always a '0' or a '5'. Spaces are used too frequently
      anyway.
==============================================================================
*/
void srand850s (char * a)
 {
   mpz_t power, current, tenk;

   initialize();

   mpz_init(current);
   mpz_init_set_ui(power, 1UL);
   mpz_init_set_ui(tenk, 10000UL);
   mpz_set_ui(state, 0);
   for ( ; *a != '\0'; a++)
    {
      if ((*a <= ' ') || (*a >= '~')) continue;

      mpz_fdiv_q(current, current, tenk);
      mpz_mul(current, current, tenk);
      mpz_add_ui(current, current, *a);
      mpz_mul(current, current, power);
      mpz_add(state, state, current);
      mpz_fdiv_q(current, current, tenk);
      mpz_mul(current, current, tenk);
      mpz_add_ui(current, current, 93);
      mpz_mul(power, power, current);

      mpz_fdiv_r(state, state, mod);
      mpz_fdiv_r(power, power, mod);
      mpz_fdiv_r(current, current, mod);
    }

   mpz_clear(power);
   mpz_clear(current);
   mpz_clear(tenk);
 }

/*
==============================================================================
   Function: random number signed long
------------------------------------------------------------------------------
   NOTES:
      Returns a "signed long" in [num_min, num_max]. Use this to ensure that
      you are using the most significant, and therefore most random, bits of
      the state in generating your random numbers. This is for those who are
      also not mathematically inclined enough to make this themselves.
==============================================================================
*/
signed long rand850sl (signed long num_min, signed long num_max)
 {
   unsigned long ra;

   ra = (unsigned long) (num_max - num_min) + 1;

   return (rand850i(ra) + num_min);
 }

#ifdef __cplusplus
 }
#endif
